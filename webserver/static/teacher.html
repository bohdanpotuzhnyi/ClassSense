<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ClassSense Teacher Dashboard</title>
    <link rel="stylesheet" href="styles.css" />
    <style>
      /* === Shared tokens (aligns regular with compact) === */
      :root {
        --brand: #0b5e8a;
        --ok: #95c11f;
        --danger: #ef4444;
        --warning: #f59e0b;
        --muted: #64748b;
        --border: #e5e7eb;
        --card: #ffffff;
        --shadow: 0 14px 30px rgba(15, 23, 42, 0.1);
      }

      /* Page + cards look like compact */
      body.teacher-shell:not(.compact-mode) {
        background: #ffffff;
        color: #0f172a;
      }
      body.teacher-shell:not(.compact-mode) .page {
        background: #fff;
        border: 1px solid var(--border);
        box-shadow: 0 18px 40px rgba(15, 23, 42, 0.12);
        border-radius: 20px;
        padding: 18px;
      }
      body.teacher-shell:not(.compact-mode) .card {
        background: #fff;
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
        border-radius: 18px;
        padding: 16px 18px;
      }

      /* Topbar + brand */
      .topbar .brand {
        color: var(--brand);
        font-weight: 700;
        letter-spacing: 0.02em;
      }

      /* Buttons */
      button.primary {
        background: var(--brand);
        color: #fff;
        border: 1px solid rgba(0, 0, 0, 0.06);
        border-radius: 12px;
        padding: 10px 14px;
        font-weight: 600;
      }
      button.ghost {
        background: #fff;
        color: #0f172a;
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 8px 12px;
      }

      section.card + section.card {
        margin-top: 16px;
      }

      .section-heading {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      /* Eyebrow + small titles */
      .eyebrow {
        text-transform: uppercase;
        letter-spacing: 0.18em;
        font-size: 11px;
        font-weight: 600;
        color: #94a3b8;
      }
      .control-title.small,
      .card h3 {
        font-size: 18px;
        margin: 2px 0 6px;
      }

      /* Pill (used for Live/Waiting & status) */
      .pill,
      .status {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: #fff;
        color: #0f172a;
        font-size: 12px;
      }
      .status.error {
        border-color: #fecaca;
        background: #fff1f2;
        color: #991b1b;
      }

      /* Sensor badges -> compact tile look */
      .env-row {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 14px;
        margin-top: 6px;
      }
      .env-badge {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 14px;
        background: #f8fafc;
      }
      .env-icon {
        width: 28px;
        text-align: center;
        font-size: 18px;
        color: var(--muted);
      }
      .env-value {
        margin-left: auto;
        color: var(--muted);
        font-size: 13px;
      }
      .env-badge::after {
        content: "";
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 999px;
        margin-left: 10px;
        background: #e2e8f0;
        box-shadow: 0 0 0 2px rgba(148, 163, 184, 0.35);
      }
      .env-badge.good::after {
        background: var(--ok);
        box-shadow: 0 0 0 2px rgba(149, 193, 31, 0.35);
      }
      .env-badge.warning::after {
        background: var(--warning);
        box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.3);
      }
      .env-badge.danger::after {
        background: var(--danger);
        box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.3);
      }

      /* ‚ÄúLatest sensor snapshot‚Äù footer */
      .muted {
        color: #64748b;
        font-size: 13px;
      }

      /* Chart card spacing + legibility */
      .chart-card h4 {
        margin: 0 0 10px;
        font-size: 16px;
      }
      canvas {
        height: 260px;
      }
      .legend {
        font-size: 12px;
        color: #64748b;
      }

      /* === Summary card === */
      .summary-card {
        padding: 16px 18px;
      }
      .summary-grid {
        display: grid;
        grid-template-columns: minmax(280px, 420px) 1fr;
        gap: 18px;
        align-items: center;
      }
      .summary-state {
        display: flex;
        align-items: center;
        gap: 14px;
      }
      .state-circle {
        --climate: #94a3b8;
        width: 76px;
        height: 76px;
        border-radius: 999px;
        display: grid;
        place-items: center;
        background: var(--climate);
        box-shadow: 0 10px 20px rgba(15, 23, 42, 0.18);
      }
      .state-circle img {
        width: 44px;
        height: 44px;
        display: block;
      }
      .state-label {
        font-weight: 800;
        letter-spacing: 0.14em;
        font-size: 14px;
        color: var(--climate);
      }
      .state-breakdown {
        font-size: 12px;
        color: #64748b;
      }
      .state-meta {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .summary-suggestion {
        border: 1px solid var(--border);
        background: #f8fafc;
        border-radius: 14px;
        padding: 10px 14px;
        font-weight: 600;
        color: #0f172a;
        width: max-content;
        justify-self: end;
        text-align: right;
        align-self: center;
      }
      @keyframes smPulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.04);
        }
        100% {
          transform: scale(1);
        }
      }
      .state-circle.pulse {
        animation: smPulse 0.6s ease;
      }

      /* Light inputs for the teacher view */
      .teacher-shell:not(.compact-mode) .pin-row input,
      .teacher-shell:not(.compact-mode) input[type="text"],
      .teacher-shell:not(.compact-mode) input[type="number"],
      .teacher-shell:not(.compact-mode) input[type="search"] {
        background: #fff;
        color: #0f172a;
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 14px;
        box-shadow:
          inset 0 2px 0 rgba(15, 23, 42, 0.03),
          0 1px 2px rgba(15, 23, 42, 0.06);
        color-scheme: light;
      }
      .teacher-shell:not(.compact-mode) input::placeholder {
        color: #94a3b8;
      }
      .teacher-shell:not(.compact-mode) input:focus {
        outline: none;
        border-color: var(--brand);
        box-shadow: 0 0 0 3px rgba(11, 94, 138, 0.15);
      }
      .teacher-shell:not(.compact-mode) input:-webkit-autofill {
        -webkit-box-shadow: 0 0 0 30px #fff inset !important;
        -webkit-text-fill-color: #0f172a !important;
      }

      /* Compact pin */
      .c-pin input {
        background: #fff;
        color: #0f172a;
        border: 1px solid #cbd5e1;
        border-radius: 999px;
      }

      .c-pin-inline {
        width: 100%;
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }
      .c-pin-inline input {
        flex: 1;
        border: 1px solid #cbd5e1;
        border-radius: 10px;
        padding: 8px 10px;
        background: #fff;
        color: #0f172a;
        font-size: 13px;
      }
      .c-pin-inline button {
        border: 1px solid #0f172a;
        background: #0f172a;
        color: #fff;
        border-radius: 10px;
        padding: 8px 12px;
        cursor: pointer;
      }

      /* Force white sensor tiles in the regular teacher view */
      .teacher-shell:not(.compact-mode) .env-row .env-badge,
      .teacher-shell:not(.compact-mode) .env-row .env-badge.elevated {
        background: #ffffff;
        color: #0f172a;
        border: 1px solid var(--border);
        border-radius: 14px;
        box-shadow:
          0 8px 18px rgba(15, 23, 42, 0.12),
          0 1px 2px rgba(15, 23, 42, 0.06);
      }
      .teacher-shell:not(.compact-mode) .env-row .env-badge .env-icon {
        color: #475569;
      }
      .teacher-shell:not(.compact-mode) .env-row .env-badge .env-value {
        color: #64748b;
      }
      .teacher-shell:not(.compact-mode) .env-row .env-badge::after {
        background: #e2e8f0;
      }
      .teacher-shell:not(.compact-mode) .env-row .env-badge.good::after {
        background: var(--ok);
      }
      .teacher-shell:not(.compact-mode) .env-row .env-badge.warning::after {
        background: var(--warning);
      }
      .teacher-shell:not(.compact-mode) .env-row .env-badge.danger::after {
        background: var(--danger);
      }
      .charts {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 16px;
      }
      .chart-card {
        padding: 14px;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: var(--card);
        box-shadow: var(--shadow);
      }
      canvas {
        width: 100%;
        height: 260px;
      }
      .legend {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        margin-top: 10px;
        font-size: 12px;
        color: #64748b;
      }
      .legend span {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .legend .dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        display: inline-block;
      }
      /* ---------- 1280 x 400 COMPACT VIEW ---------- */

      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
      }

      /* blue background that the card sits on */
      body.compact-mode {
        background: #000;
        color: #0f172a;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* Regular teacher view theming */
      body.teacher-shell:not(.compact-mode) {
        background: #ffffff;
        color: #0f172a;
      }

      body.teacher-shell:not(.compact-mode) .page {
        background: #ffffff;
        border: 1px solid #e5e7eb;
        box-shadow: 0 18px 40px rgba(15, 23, 42, 0.12);
      }

      body.teacher-shell:not(.compact-mode) .card {
        background: #ffffff;
        border: 1px solid #e5e7eb;
        box-shadow: 0 14px 30px rgba(15, 23, 42, 0.1);
      }

      body.teacher-shell:not(.compact-mode) .topbar .brand {
        color: #0b5e8a;
      }

      body.teacher-shell:not(.compact-mode) button.primary {
        background: #0b5e8a;
        color: #fff;
        border: 1px solid rgba(0, 0, 0, 0.08);
      }

      body.teacher-shell:not(.compact-mode) button.ghost {
        border-color: #e5e7eb;
        color: #0f172a;
      }

      .logo-chip {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        background: #0b5e8a;
        border-radius: 10px;
        color: #fff;
        font-weight: 600;
      }

      .logo-chip img {
        height: 22px;
        width: auto;
        display: block;
        filter: brightness(1.1);
      }

      /* outer container is exactly 1280 x 400 */
      #compactView {
        display: block;
        width: 1280px;
        height: 400px;
        background: transparent;
      }

      /* inner card (white + blue areas) */
      #compactView .display {
        width: 100%;
        height: 100%;
        display: grid;
        grid-template-columns: 340px 1fr 360px;
        background: #ffffff;
        border-radius: 24px;
        overflow: hidden;
        box-shadow: 0 24px 45px rgba(15, 23, 42, 0.45);
        position: relative;
      }

      /* ----- left column: environment ----- */

      .c-env {
        background: #f8fafc;
        padding: 24px 40px 24px;
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .c-env .eyebrow {
        text-align: left;
        text-transform: uppercase;
        letter-spacing: 0.18em;
        font-size: 11px;
        font-weight: 600;
        color: #64748b;
      }

      /* list of rows */
      .c-env-list {
        display: flex;
        flex-direction: column;
        gap: 2px;
        flex: 1;
        justify-content: center;
      }

      /* each row */
      .c-env-tile {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        padding: 8px 0;
        border: none;
        background: transparent;
      }

      /* left: label & value */
      .c-env-meta {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      .c-env-label {
        font-weight: 600;
        font-size: 22px;
        color: #0f172a;
      }

      .c-env-value {
        color: #64748b;
        font-size: 18px;
      }

      /* right: three small indicator circles */
      .c-env-dots {
        display: flex;
        gap: 8px;
        margin-left: auto;
        align-items: center;
      }

      .c-env-row {
        display: flex;
        align-items: center;
        gap: 12px;
        width: 100%;
      }

      .c-env-icon {
        font-size: 20px;
        width: 28px;
        text-align: center;
        color: #64748b;
      }

      .c-env-meta {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      .c-env-dot {
        width: 18px;
        height: 18px;
        border-radius: 999px;
        background: #e2e8f0;
        box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.4);
      }

      .c-env-dot.is-good {
        background: #95c11f;
        box-shadow: 0 0 0 4px rgba(149, 193, 31, 0.25);
      }

      .c-env-dot.is-warning {
        background: #f59e0b;
        box-shadow: 0 0 0 4px rgba(245, 158, 11, 0.25);
      }

      .c-env-dot.is-danger {
        background: #ef4444;
        box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.25);
      }

      .c-env-footer {
        font-size: 12px;
        color: #94a3b8;
        text-align: center;
      }

      /* ----- center column: climate circle ----- */

      .c-center-wrap {
        background: #ffffff;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        justify-content: flex-start;
        padding: 24px 0 24px;
        gap: 8px;
      }

      .c-center-heading {
        display: flex;
        justify-content: center;
        text-transform: uppercase;
        letter-spacing: 0.18em;
        font-size: 11px;
        font-weight: 600;
        color: #94a3b8;
      }

      .c-center {
        --climate-color: #95c11f;
        --climate-tint: color-mix(in srgb, var(--climate-color) 90%, #fff 10%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        text-align: center;
        flex: 1;
        justify-content: center;
      }

      .c-circle {
        position: relative;
        width: 220px;
        height: 220px;
        border-radius: 50%;
        display: grid;
        place-items: center;
        font-size: 64px;
        color: #ffffff;
        background: var(--climate-color);
        box-shadow: 0 18px 38px rgba(0, 0, 0, 0.25);
      }

      .c-circle::after {
        display: none;
      }

      .state-icon {
        width: 128px;
        height: 128px;
        display: block;
        margin: 0 auto;
      }
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      .circle-pulse {
        animation: pulse 0.6s ease;
      }

      .c-label {
        letter-spacing: 0.18em;
        font-weight: 700;
        font-size: 16px;
        color: var(--climate-color);
        transition: color 0.3s ease;
      }

      .c-center-helper {
        font-size: 12px;
        color: color-mix(in srgb, var(--climate-color) 50%, #64748b);
      }

      @supports not (color: color-mix(in srgb, white 50%, black 50%)) {
        .c-center-helper {
          opacity: 0.6;
        }
      }

      /* ----- right column: brand + message ----- */

      .c-right {
        background: linear-gradient(135deg, #0b5e8a, #00456a, #0b5e8a);
        background-size: 200% 200%;
        animation: panelShift 14s ease-in-out infinite;
        color: #ffffff;
        padding: 28px 36px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        overflow: hidden;
      }

      .c-brand {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 20px;
        font-weight: 700;
        letter-spacing: 0.06em;
      }

      .c-brand img {
        height: 34px;
        width: auto;
      }

      .c-message {
        font-size: 28px;
        line-height: 1.25;
        text-align: left;
        flex: 1 1 100%;
        display: flex;
        align-items: center;
        padding-left: 8px;
        justify-content: center;
        font-weight: 700;
      }

      /* pin box stays small and flat on top */
      .c-pin {
        position: absolute;
        top: 16px;
        left: 24px;
        display: flex;
        gap: 6px;
        align-items: center;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 999px;
        padding: 4px 8px;
        border: 1px solid #cbd5e1;
      }

      .c-pin input {
        border: none;
        padding: 4px 8px;
        outline: none;
        font-size: 13px;
        border-radius: 999px;
      }

      .c-pin button {
        border: none;
        background: #0f172a;
        color: #fff;
        padding: 6px 10px;
        font-size: 12px;
        cursor: pointer;
        border-radius: 999px;
      }

      .pin-badge {
        display: none;
        align-items: center;
        justify-content: center;
        min-width: 160px;
        padding: 10px 14px;
        background: rgba(255, 255, 255, 0.14);
        border: 1px solid rgba(255, 255, 255, 0.28);
        border-radius: 14px;
        font-size: 24px;
        font-weight: 800;
        letter-spacing: 0.12em;
        color: #fff;
        text-align: center;
        cursor: pointer;
      }

      .breakdown-overlay {
        position: fixed;
        inset: 0;
        background: rgba(6, 12, 24, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 999;
        padding: 18px;
        backdrop-filter: blur(4px);
      }
      .breakdown-overlay.show {
        display: flex;
      }
      .breakdown-card {
        background: #0b172b;
        color: #e2e8f0;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 18px;
        padding: 18px;
        width: min(700px, 96vw);
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.4);
      }
      .breakdown-header {
        text-align: center;
        margin-bottom: 12px;
      }
      .breakdown-header .title {
        text-transform: uppercase;
        letter-spacing: 0.18em;
        font-size: 12px;
        color: #a5b4fc;
      }
      .breakdown-header .subtitle {
        font-size: 18px;
        font-weight: 700;
        margin-top: 6px;
      }
      .breakdown-bars {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin: 10px 0;
      }
      .breakdown-row {
        display: grid;
        grid-template-columns: 1fr 2fr 60px;
        align-items: center;
        gap: 10px;
      }
      .breakdown-label {
        display: flex;
        align-items: center;
        gap: 8px;
        font-weight: 600;
      }
      .bd-dot {
        width: 12px;
        height: 12px;
        border-radius: 999px;
        display: inline-block;
      }
      .bd-ok {
        background: #95c11f;
        box-shadow: 0 0 0 4px rgba(149, 193, 31, 0.25);
      }
      .bd-overloaded {
        background: #facc15;
        box-shadow: 0 0 0 4px rgba(250, 204, 21, 0.25);
      }
      .bd-tired {
        background: #0ea5e9;
        box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.25);
      }
      .bd-lost {
        background: #ef4444;
        box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.25);
      }
      .breakdown-track {
        position: relative;
        width: 100%;
        height: 12px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.08);
        overflow: hidden;
      }
      .breakdown-fill {
        position: absolute;
        inset: 0;
        width: 0%;
        border-radius: 999px;
        transition: width 0.3s ease;
      }
      .fill-ok {
        background: linear-gradient(90deg, #7bb314, #95c11f);
      }
      .fill-overloaded {
        background: linear-gradient(90deg, #fcd34d, #facc15);
      }
      .fill-tired {
        background: linear-gradient(90deg, #22c55e, #0ea5e9);
      }
      .fill-lost {
        background: linear-gradient(90deg, #f97316, #ef4444);
      }
      .breakdown-val {
        text-align: right;
        font-weight: 700;
      }
      .breakdown-footer {
        text-align: center;
        color: #cbd5e1;
        font-size: 13px;
        margin-top: 12px;
        letter-spacing: 0.08em;
      }

      @keyframes bgShift {
        0% {
          background-position: 0% 0%, 100% 50%, 0% 50%;
        }
        50% {
          background-position: 40% 30%, 60% 70%, 100% 60%;
        }
        100% {
          background-position: 0% 0%, 100% 50%, 0% 50%;
        }
      }

      @keyframes panelShift {
        0% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
        100% {
          background-position: 0% 50%;
        }
      }

      /* (optional) if window slightly smaller, scale a bit */
      @media (max-width: 1260px) {
        #compactView .display {
          transform: scale(0.95);
          transform-origin: center;
        }
      }

      /* Display-only mode (no pin inputs or controls) */
      body.display-only .c-pin,
      body.display-only .c-pin-inline,
      body.display-only .pin-row,
      body.display-only #downloadState {
        display: none !important;
      }
      body.display-only #status {
        margin-top: 0;
      }
    </style>
  </head>
  <body class="teacher-shell">
    <div id="compactView">
      <div class="c-pin">
        <input id="cPinInput" type="text" maxlength="5" placeholder="PIN" data-i18n-placeholder="pin_short_placeholder" />
        <button id="cConnectBtn" data-i18n="connect_short">Los</button>
      </div>
      <div class="display">
        <div class="c-env">
          <div class="c-env-list" id="cEnvList"></div>
        </div>
        <div class="c-center-wrap">
          <div class="c-center-heading" data-i18n="compact_climate_heading">Klassenklima</div>
          <div class="c-center">
            <div class="c-circle" id="cCircle"><span id="cEmoji" class="c-icon"></span></div>
            <div class="c-label" id="cLabel" data-i18n="state_waiting_label">WARTET</div>
          </div>
        </div>
        <div class="c-right">
          <div class="c-brand">
            <div style="font-size:24px;font-weight:700;letter-spacing:0.04em;">ClassSense</div>
            <img src="st-klemens-logo-white.png" alt="Gymnasium logo" />
          </div>
          <div class="c-message" id="cMessage" data-i18n="compact_waiting_message">Warte auf Daten</div>
          <div id="cPinBadge" class="pin-badge">PIN</div>
          <div class="c-pin-inline">
            <input id="cPinInputInline" type="text" maxlength="5" placeholder="PIN" data-i18n-placeholder="pin_short_placeholder" />
            <button id="cConnectBtnInline" data-i18n="connect_short">Los</button>
          </div>
        </div>
      </div>
    </div>

      <div id="regularView" class="page">
        <header class="topbar">
        <div class="brand" data-i18n="teacher_dashboard">Lehrer-Dashboard</div>
        <div class="actions">
          <div class="logo-chip">
            <img src="st-klemens-logo-white.png" alt="Gymnasium logo" />
          </div>
          <button id="downloadState" class="ghost" disabled data-i18n="download_state">Klassenstatus herunterladen</button>
          <button id="themeToggle" class="ghost" data-i18n="theme_dark">Dunkel</button>
        </div>
      </header>

      <section class="card">
        <div class="pin-row">
          <input id="pinInput" type="text" maxlength="5" placeholder="Klassen-PIN" data-i18n-placeholder="pin_placeholder" />
          <button id="connectBtn" class="primary" data-i18n="connect_poll">Verbinden & abrufen</button>
        </div>
        <div id="status" class="status" data-i18n="status_prompt">Gib eine Klassen-PIN ein, um die Aktivit√§t zu sehen.</div>
      </section>

      <section class="card">
        <div class="section-heading" style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <div class="eyebrow" data-i18n="room_snapshot">Raum-√úberblick</div>
            <h3 data-i18n="latest_sensor_snapshot">Letzte Sensordaten</h3>
          </div>
          <div class="pill muted" id="sensorPill" data-i18n="pill_waiting">Wartet</div>
        </div>
        <div id="sensors" class="env-row"></div>
        <div class="muted" id="lastSensor" data-i18n="last_sensor">Letzter Sensor: keiner</div>
      </section>

      <section class="card summary-card" id="summaryCard">
        <div class="section-heading" style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <div class="eyebrow" data-i18n="classroom_climate">Klassenklima</div>
            <h3 data-i18n="summary_title">Zusammenfassung</h3>
          </div>
          <div class="pill muted" id="summaryPill" data-i18n="pill_waiting">Wartet</div>
        </div>

        <div class="summary-grid">
          <div class="summary-state">
            <div class="state-circle" id="summaryCircle">
              <span id="summaryIcon"></span>
            </div>
            <div class="state-meta">
              <div id="summaryLabel" class="state-label" data-i18n="state_waiting_label">WARTET</div>
              <div id="summaryBreakdown" class="state-breakdown">‚Äî</div>
            </div>
          </div>

          <div class="summary-suggestion" id="summarySuggestion">
            <span data-i18n="summary_suggestion_waiting">Warte auf Daten</span>
          </div>
        </div>
      </section>

      <section class="card">
        <div class="section-heading" style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <div class="eyebrow" data-i18n="classroom_climate">Klassenklima</div>
            <h3 data-i18n="class_signals">Klassensignale</h3>
          </div>
          <div class="pill muted" id="livePill" data-i18n="pill_waiting">Wartet</div>
        </div>
        <div class="charts">
          <div class="chart-card">
            <h4 data-i18n="chart_title">CO‚ÇÇ & Emotionen pro Minute</h4>
            <canvas id="signalChart"></canvas>
            <div class="legend">
              <span><span class="dot" style="background:#0ea5e9;"></span><span data-i18n="legend_too_fast">Zu schnell</span></span>
              <span><span class="dot" style="background:#6366f1;"></span><span data-i18n="legend_overloaded">√úberfordert</span></span>
              <span><span class="dot" style="background:#22c55e;"></span><span data-i18n="legend_ok">OK</span></span>
              <span><span class="dot" style="background:#facc15;"></span><span data-i18n="legend_tired">M√ºde</span></span>
              <span><span class="dot" style="background:#8b5cf6;"></span><span data-i18n="legend_focus_avg">Fokus √ò</span></span>
              <span><span class="dot" style="background:#f97316;"></span><span data-i18n="legend_co2">CO‚ÇÇ (ppm)</span></span>
            </div>
          </div>
        </div>
      </section>
    </div>

    <div id="breakdownOverlay" class="breakdown-overlay">
      <div id="breakdownCard" class="breakdown-card">
        <div class="breakdown-header">
          <div class="title" data-i18n="breakdown_title">Klassenklima</div>
          <div class="subtitle" data-i18n="breakdown_subtitle">Antworten der letzten Minute</div>
        </div>
        <div class="breakdown-bars">
          <div class="breakdown-row">
            <div class="breakdown-label"><span class="bd-dot bd-ok"></span><span data-i18n="breakdown_ok">Im Flow / OK</span></div>
            <div class="breakdown-track"><div id="fillOk" class="breakdown-fill fill-ok"></div></div>
            <div id="valOk" class="breakdown-val">0%</div>
          </div>
          <div class="breakdown-row">
            <div class="breakdown-label"><span class="bd-dot bd-overloaded"></span><span data-i18n="breakdown_overloaded">√úberfordert</span></div>
            <div class="breakdown-track"><div id="fillOverloaded" class="breakdown-fill fill-overloaded"></div></div>
            <div id="valOverloaded" class="breakdown-val">0%</div>
          </div>
          <div class="breakdown-row">
            <div class="breakdown-label"><span class="bd-dot bd-tired"></span><span data-i18n="breakdown_tired">M√ºde</span></div>
            <div class="breakdown-track"><div id="fillTired" class="breakdown-fill fill-tired"></div></div>
            <div id="valTired" class="breakdown-val">0%</div>
          </div>
          <div class="breakdown-row">
            <div class="breakdown-label"><span class="bd-dot bd-lost"></span><span data-i18n="breakdown_lost">Verloren / Unsicher</span></div>
            <div class="breakdown-track"><div id="fillLost" class="breakdown-fill fill-lost"></div></div>
            <div id="valLost" class="breakdown-val">0%</div>
          </div>
        </div>
        <div class="breakdown-footer" data-i18n="breakdown_footer">Zum Schlie√üen tippen</div>
      </div>
    </div>

    <script>
      const translations = {
        de: {
          theme_light: "Hell",
          theme_dark: "Dunkel",
          teacher_dashboard: "Lehrer-Dashboard",
          download_state: "Klassenstatus herunterladen",
          pin_placeholder: "Klassen-PIN",
          pin_short_placeholder: "PIN",
          connect_poll: "Verbinden & abrufen",
          connect_short: "Los",
          status_prompt: "Gib eine Klassen-PIN ein, um die Aktivit√§t zu sehen.",
          status_prompt_compact: "Gib eine Klassen-PIN ein.",
          status_connected_with_count: "Mit {pin} verbunden, Eintr√§ge: {count}",
          status_connected: "Mit {pin} verbunden",
          status_fetch_failed: "Status konnte nicht geladen werden.",
          status_pin_required: "Bitte eine PIN eingeben.",
          status_connecting: "Verbinde‚Ä¶",
          status_download_ok: "Status f√ºr {pin} heruntergeladen",
          status_download_fail: "Konnte Klassenstatus nicht herunterladen.",
          pill_live: "Live",
          pill_waiting: "Wartet",
          room_snapshot: "Raum-√úberblick",
          latest_sensor_snapshot: "Letzte Sensordaten",
          last_sensor: "Letzter Sensor: {time}",
          none: "keine",
          classroom_climate: "Klassenklima",
          summary_title: "Zusammenfassung",
          summary_suggestion_waiting: "Warte auf Daten",
          class_signals: "Klassensignale",
          chart_title: "CO‚ÇÇ & Emotionen pro Minute",
          legend_too_fast: "Zu schnell",
          legend_overloaded: "√úberfordert",
          legend_ok: "OK",
          legend_tired: "M√ºde",
          legend_focus_avg: "Fokus √ò",
          legend_co2: "CO‚ÇÇ (ppm)",
          breakdown_title: "Klassenklima",
          breakdown_subtitle: "Antworten der letzten Minute",
          breakdown_ok: "Im Flow / OK",
          breakdown_overloaded: "√úberfordert",
          breakdown_tired: "M√ºde",
          breakdown_lost: "Verloren / Unsicher",
          breakdown_footer: "Zum Schlie√üen tippen",
          compact_environment: "Umgebung",
          compact_climate_heading: "Klassenklima",
          state_waiting_label: "WARTET",
          compact_waiting_message: "Warte auf Daten",
          chart_no_data: "Noch keine Daten. Verbinden, um zu starten.",
          chart_axis_left: "Emotionen pro Typ / Fokus √ò (0‚Äì100)",
          chart_axis_right: "CO‚ÇÇ {min}‚Äì{max} ppm",
          state_engaged: "IM FLOW",
          state_lost: "VERLOREN",
          state_overload: "√úBERLASTET",
          state_tired: "M√úDE",
          state_waiting: "WARTET",
          state_idle: "WARTET",
          state_monitor: "BEOBACHTEN",
          message_open_window: "Fenster √∂ffnen",
          message_waiting_feedback: "Warte auf Feedback",
          message_engaged: "Klasse ist im Flow",
          message_overloaded: "Tempo drosseln & wiederholen",
          message_tired: "Zeit f√ºr eine Pause",
          message_lost: "Kurz stoppen & kl√§ren",
          message_monitor: "Klasse beobachten",
          summary_no_recent: "Kein aktuelles Feedback (letzte {span}s)",
          summary_breakdown:
            "OK {ok}% ¬∑ Verloren {lost}% ¬∑ √úberlastet {overload}% ¬∑ M√ºde {tired}% (letzte {span}s)",
          env_air: "Luft",
          env_temp: "Temperatur",
          env_noise: "L√§rm",
          env_voc: "VOC",
          env_lux: "Licht",
          env_footer: "Tippe f√ºr Werte",
          not_available: "k. A.",
          sensor_temp_label: "¬∞C",
          sensor_co2_label: "CO‚ÇÇ",
          sensor_noise_label: "üîä",
          sensor_lux_label: "Lux",
          sensor_voc_label: "VOC",
        },
        en: {
          theme_light: "Light",
          theme_dark: "Dark",
          teacher_dashboard: "Teacher Dashboard",
          download_state: "Download class state",
          pin_placeholder: "Class PIN",
          pin_short_placeholder: "PIN",
          connect_poll: "Connect & Poll",
          connect_short: "Go",
          status_prompt: "Enter a class PIN to view activity.",
          status_prompt_compact: "Enter a class PIN.",
          status_connected_with_count: "Connected to {pin}, entries: {count}",
          status_connected: "Connected to {pin}",
          status_fetch_failed: "Failed to fetch state.",
          status_pin_required: "Please enter a PIN.",
          status_connecting: "Connecting‚Ä¶",
          status_download_ok: "Downloaded state for {pin}",
          status_download_fail: "Could not download class state.",
          pill_live: "Live",
          pill_waiting: "Waiting",
          room_snapshot: "Room snapshot",
          latest_sensor_snapshot: "Latest sensor snapshot",
          last_sensor: "Last sensor: {time}",
          none: "none",
          classroom_climate: "Classroom climate",
          summary_title: "Summary",
          summary_suggestion_waiting: "Waiting for data",
          class_signals: "Class signals",
          chart_title: "Per-minute CO‚ÇÇ & emotions",
          legend_too_fast: "Too fast",
          legend_overloaded: "Overloaded",
          legend_ok: "OK",
          legend_tired: "Tired",
          legend_focus_avg: "Focus avg",
          legend_co2: "CO‚ÇÇ (ppm)",
          breakdown_title: "Classroom climate",
          breakdown_subtitle: "Last minute responses",
          breakdown_ok: "Engaged / OK",
          breakdown_overloaded: "Overloaded",
          breakdown_tired: "Tired",
          breakdown_lost: "Lost / Confused",
          breakdown_footer: "Tap anywhere to close",
          compact_environment: "Environment",
          compact_climate_heading: "Classroom climate",
          state_waiting_label: "WAITING",
          compact_waiting_message: "Waiting for data",
          chart_no_data: "No data yet. Connect to start polling.",
          chart_axis_left: "Emotions per type / Focus avg (0‚Äì100)",
          chart_axis_right: "CO‚ÇÇ {min}‚Äì{max} ppm",
          state_engaged: "ENGAGED",
          state_lost: "LOST",
          state_overload: "OVERLOAD",
          state_tired: "TIRED",
          state_waiting: "WAITING",
          state_idle: "WAITING",
          state_monitor: "MONITOR",
          message_open_window: "Open the window",
          message_waiting_feedback: "Waiting for feedback",
          message_engaged: "Class is engaged",
          message_overloaded: "Slow down & review",
          message_tired: "Time for a break",
          message_lost: "Pause & clarify",
          message_monitor: "Monitor class",
          summary_no_recent: "No recent feedback (last {span}s)",
          summary_breakdown:
            "OK {ok}% ¬∑ Lost {lost}% ¬∑ Overload {overload}% ¬∑ Tired {tired}% (last {span}s)",
          env_air: "Air",
          env_temp: "Temp",
          env_noise: "Noise",
          env_voc: "VOC",
          env_lux: "Lux",
          env_footer: "Tap for values",
          not_available: "n/a",
          sensor_temp_label: "¬∞C",
          sensor_co2_label: "CO‚ÇÇ",
          sensor_noise_label: "üîä",
          sensor_lux_label: "Lux",
          sensor_voc_label: "VOC",
        },
      };

      const fallbackLang = "de";
      const supportedLangs = Object.keys(translations);
      const normalizeLang = (lang) => (lang || "").toLowerCase();
      const detectLanguage = () => {
        const params = new URLSearchParams(window.location.search);
        const qLang = normalizeLang(params.get("lang"));
        if (supportedLangs.includes(qLang)) {
          localStorage?.setItem?.("lang", qLang);
          return qLang;
        }
        const stored = normalizeLang(localStorage?.getItem?.("lang"));
        if (supportedLangs.includes(stored)) return stored;
        return fallbackLang;
      };

      let lang = detectLanguage();

      const t = (key, vars = {}) => {
        const dict = translations[lang] || translations[fallbackLang];
        const template = dict[key] ?? translations[fallbackLang]?.[key] ?? key;
        return template.replace(/\{(\w+)\}/g, (_, k) => (vars[k] != null ? vars[k] : `{${k}}`));
      };

      document.documentElement?.setAttribute("lang", lang);

      const prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
      let theme = prefersDark ? "dark" : "light";
      const updateThemeLabel = () => {
        if (themeBtn) themeBtn.textContent = theme === "dark" ? t("theme_light") : t("theme_dark");
      };
      const setTheme = (th) => {
        theme = th;
        document.documentElement.classList.toggle("dark", th === "dark");
        updateThemeLabel();
      };

      let pollTimer = null;
      let pin = "";
      let breakdownVisible = false;

      const statusEl = document.getElementById("status");
      const sensorsEl = document.getElementById("sensors");
      const lastSensorEl = document.getElementById("lastSensor");
      const signalCanvas = document.getElementById("signalChart");
      const ctx = signalCanvas.getContext("2d");
      const themeBtn = document.getElementById("themeToggle");
      const downloadBtn = document.getElementById("downloadState");
      const compactView = document.getElementById("compactView");
      const regularView = document.getElementById("regularView");
      const cPinInput = document.getElementById("cPinInput");
      const cConnectBtn = document.getElementById("cConnectBtn");
      const cPinInputInline = document.getElementById("cPinInputInline");
      const cConnectBtnInline = document.getElementById("cConnectBtnInline");
      const cMessage = document.getElementById("cMessage");
      const pinInput = document.getElementById("pinInput");
      const connectBtn = document.getElementById("connectBtn");
      const cPinBadge = document.getElementById("cPinBadge");
      const sensorPill = document.getElementById("sensorPill");
      const summaryPill = document.getElementById("summaryPill");
      const livePill = document.getElementById("livePill");
      const summarySuggestion = document.getElementById("summarySuggestion");
      const cLabelEl = document.getElementById("cLabel");
      const breakdownOverlay = document.getElementById("breakdownOverlay");
      const breakdownCard = document.getElementById("breakdownCard");
      const cCenter = document.querySelector(".c-center");
      let lastBreakdown = computeBreakdown([], 60_000);

      // Simple in-memory histories (per minute) for charting
      const co2History = new Map(); // minuteKey -> ppm
      const emotionBuckets = new Map(); // minuteKey -> { counts: Map<key,count>, focusSum, focusCount }

      const EMOTION_COLORS = {
        "too-fast": "#0ea5e9",
        overloaded: "#6366f1",
        ok: "#22c55e",
        tired: "#facc15",
      };

      function applyMode() {
        const useCompact = window.innerWidth <= 1300 && window.innerHeight <= 420;
        document.body.classList.toggle("compact-mode", useCompact);
        if (compactView) compactView.style.display = useCompact ? "block" : "none";
        if (regularView) regularView.style.display = useCompact ? "none" : "block";
        updatePinUI();
      }

      const minuteKey = (ts) => {
        const t = new Date(ts);
        return `${t.getHours().toString().padStart(2, "0")}:${t.getMinutes().toString().padStart(2, "0")}`;
      };

      function setPin(newPin) {
        pin = newPin;
        if (pinInput) pinInput.value = newPin;
        if (cPinInput) cPinInput.value = newPin;
        if (cPinInputInline) cPinInputInline.value = newPin;
        updatePinUI();
      }

      function pruneHistory(map, keep = 120) {
        const keys = Array.from(map.keys()).sort();
        while (keys.length > keep) {
          const k = keys.shift();
          map.delete(k);
        }
      }

      function setStatus(msg, isErr = false) {
        statusEl.textContent = msg;
        statusEl.className = isErr ? "status error" : "status";
      }

      function setStatusCompact(msg) {
        if (cMessage) cMessage.textContent = msg;
      }

      function applyTranslations() {
        document.documentElement?.setAttribute("lang", lang);
        document.querySelectorAll("[data-i18n]").forEach((el) => {
          const key = el.dataset.i18n;
          if (!key) return;
          el.textContent = t(key);
        });
        document.querySelectorAll("[data-i18n-placeholder]").forEach((el) => {
          const key = el.dataset.i18nPlaceholder;
          if (key) el.setAttribute("placeholder", t(key));
        });
        setStatus(t("status_prompt"));
        setStatusCompact(t("status_prompt_compact"));
        if (lastSensorEl) lastSensorEl.textContent = t("last_sensor", { time: t("none") });
        if (sensorPill) sensorPill.textContent = t("pill_waiting");
        if (summaryPill) summaryPill.textContent = t("pill_waiting");
        if (livePill) livePill.textContent = t("pill_waiting");
        if (summarySuggestion) summarySuggestion.textContent = t("summary_suggestion_waiting");
        if (cLabelEl) cLabelEl.textContent = t("state_waiting_label");
        if (cMessage) cMessage.textContent = t("compact_waiting_message");
        updateThemeLabel();
      }

      function renderSensors(sensor) {
        const s = sensor?.sensors || {};
        const statusFor = (type, val) => {
          if (val == null) return "warning";
          if (type === "co2") return val <= 800 ? "good" : val <= 1200 ? "warning" : "danger";
          if (type === "temperature") return val >= 20 && val <= 24 ? "good" : val >= 18 && val <= 27 ? "warning" : "danger";
          if (type === "noise") return val <= 50 ? "good" : val <= 65 ? "warning" : "danger";
          return "good";
        };

        const rows = [
          {
            label: t("sensor_temp_label"),
            value: s.temperature_c != null ? `${Math.round(s.temperature_c)}¬∞C` : t("not_available"),
            status: statusFor("temperature", s.temperature_c),
          },
          {
            label: t("sensor_co2_label"),
            value: s.eco2_ppm != null ? `${Math.round(s.eco2_ppm)} ppm` : t("not_available"),
            status: statusFor("co2", s.eco2_ppm),
          },
          {
            label: t("sensor_noise_label"),
            value: s.noise_db != null ? `${Math.round(s.noise_db)} dB` : t("not_available"),
            status: statusFor("noise", s.noise_db),
          },
          {
            label: t("sensor_lux_label"),
            value: s.brightness_lux != null ? `${Math.round(s.brightness_lux)} lx` : t("not_available"),
            status: statusFor("lux", s.brightness_lux),
          },
          {
            label: t("sensor_voc_label"),
            value: s.voc_ppb != null ? `${Math.round(s.voc_ppb)} ppb` : t("not_available"),
            status: statusFor("voc", s.voc_ppb),
          },
        ];

        sensorsEl.innerHTML = rows
          .map(
            (r) => `
          <div class="env-badge ${r.status}">
            <div class="env-icon">${r.label}</div>
            <div class="env-value">${r.value}</div>
          </div>
        `
          )
          .join("");
        lastSensorEl.textContent = t("last_sensor", { time: sensor?.timestamp || t("none") });

        // Track CO‚ÇÇ history for the chart (bucketed per minute)
        if (sensor?.sensors?.eco2_ppm != null) {
          const key = minuteKey(sensor.timestamp || Date.now());
          co2History.set(key, Math.round(sensor.sensors.eco2_ppm));
          pruneHistory(co2History);
        }
      }

      function aggregateEmotions(emotions = []) {
        emotionBuckets.clear();
        emotions.forEach((e) => {
          const key = minuteKey(e.received_at);
          if (!emotionBuckets.has(key)) emotionBuckets.set(key, { counts: new Map(), focusSum: 0, focusCount: 0 });
          const bucket = emotionBuckets.get(key);
          const payload = e.payload || {};
          if (typeof payload.focus === "number") {
            bucket.focusSum += Number(payload.focus);
            bucket.focusCount += 1;
          }
          if (payload.pace) {
            bucket.counts.set(payload.pace, (bucket.counts.get(payload.pace) || 0) + 1);
          }
        });
        pruneHistory(emotionBuckets);
      }

      function renderChart() {
        const labels = Array.from(new Set([...co2History.keys(), ...emotionBuckets.keys()])).sort();

        // If we have gaps, ensure every minute has a bucket & co2 value
        labels.forEach((l) => {
          if (!emotionBuckets.has(l)) emotionBuckets.set(l, { counts: new Map(), focusSum: 0, focusCount: 0 });
          if (!co2History.has(l)) co2History.set(l, 0);
        });

        signalCanvas.width = signalCanvas.clientWidth;
        signalCanvas.height = signalCanvas.clientHeight;
        ctx.clearRect(0, 0, signalCanvas.width, signalCanvas.height);

        if (!labels.length) {
          ctx.fillStyle = "#64748b";
          ctx.font = "14px sans-serif";
          ctx.fillText(t("chart_no_data"), 12, 24);
          return;
        }

        const leftPad = 44;
        const rightPad = 52;
        const topPad = 16;
        const bottomPad = 32;
        const w = signalCanvas.width;
        const h = signalCanvas.height;
        const plotW = w - leftPad - rightPad;
        const plotH = h - topPad - bottomPad;

        const co2Vals = labels.map((l) => co2History.get(l) ?? 0);

        // max stack of emotion counts per minute
        const maxStack = Math.max(
          ...labels.map((l) => {
            const bucket = emotionBuckets.get(l);
            if (!bucket) return 0;
            return Array.from(bucket.counts.values()).reduce((a, b) => a + b, 0);
          }),
          1
        );

        // per-minute average focus (0‚Äì100)
        const maxFocus = Math.max(
          ...labels.map((l) => {
            const bucket = emotionBuckets.get(l);
            return bucket && bucket.focusCount ? bucket.focusSum / bucket.focusCount : 0;
          }),
          0,
          100
        );

        const maxEmotionScale = Math.max(maxStack, maxFocus);
        const maxCo2 = Math.max(...co2Vals, 400);
        const minCo2 = Math.min(...co2Vals, 0);

        const xFor = (idx) =>
          leftPad + (labels.length === 1 ? plotW / 2 : (idx / (labels.length - 1)) * plotW);
        const yEmotion = (v) => topPad + plotH - (v / maxEmotionScale) * plotH;
        const yCo2 = (v) =>
          topPad + plotH - ((v - minCo2) / Math.max(maxCo2 - minCo2 || 1, 1)) * plotH;

        // --- grid lines ---
        ctx.strokeStyle = "rgba(15,23,42,0.06)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        [0, 0.5, 1].forEach((p) => {
          const y = topPad + plotH * p;
          ctx.moveTo(leftPad, y);
          ctx.lineTo(w - rightPad, y);
        });
        ctx.stroke();

        // -------- EMOTION LINES (one per type) --------
        const EMOTION_KEYS = ["too-fast", "overloaded", "ok", "tired"];

        EMOTION_KEYS.forEach((key) => {
          ctx.strokeStyle = EMOTION_COLORS[key] || "#94a3b8";
          ctx.lineWidth = 2;
          ctx.beginPath();
          let started = false;

          labels.forEach((l, idx) => {
            const bucket = emotionBuckets.get(l);
            const v = bucket ? bucket.counts.get(key) || 0 : 0;
            const x = xFor(idx);
            const y = yEmotion(v);

            if (!started) {
              ctx.moveTo(x, y);
              started = true;
            } else {
              ctx.lineTo(x, y);
            }
          });

          if (started) ctx.stroke();
        });

        // -------- FOCUS AVERAGE LINE --------
        ctx.strokeStyle = "#8b5cf6";
        ctx.fillStyle = "#8b5cf6";
        ctx.lineWidth = 2;
        let startedFocus = false;
        ctx.beginPath();

        labels.forEach((l, idx) => {
          const bucket = emotionBuckets.get(l);
          if (!bucket || !bucket.focusCount) return;
          const avg = bucket.focusSum / bucket.focusCount; // per-minute weighted by count
          const x = xFor(idx);
          const y = yEmotion(avg);

          if (!startedFocus) {
            ctx.moveTo(x, y);
            startedFocus = true;
          } else {
            ctx.lineTo(x, y);
          }
        });

        if (startedFocus) {
          ctx.stroke();
          // draw focus points
          labels.forEach((l, idx) => {
            const bucket = emotionBuckets.get(l);
            if (!bucket || !bucket.focusCount) return;
            const avg = bucket.focusSum / bucket.focusCount;
            const x = xFor(idx);
            const y = yEmotion(avg);
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
          });
        }

        // -------- CO‚ÇÇ LINE (no fill) --------
        ctx.strokeStyle = "#f97316";
        ctx.fillStyle = "#f97316";
        ctx.lineWidth = 2;
        let startedCo2 = false;
        ctx.beginPath();

        labels.forEach((l, idx) => {
          const val = co2History.get(l) ?? 0;
          const x = xFor(idx);
          const y = yCo2(val);
          if (!startedCo2) {
            ctx.moveTo(x, y);
            startedCo2 = true;
          } else {
            ctx.lineTo(x, y);
          }
        });

        if (startedCo2) {
          ctx.stroke();
          // draw CO‚ÇÇ points
          labels.forEach((l, idx) => {
            const val = co2History.get(l) ?? 0;
            const x = xFor(idx);
            const y = yCo2(val);
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
          });
        }

        // -------- axes labels / x-ticks --------
        ctx.fillStyle = "#64748b";
        ctx.font = "11px sans-serif";

        labels.forEach((l, idx) => {
          const x = xFor(idx);
          ctx.textAlign = "center";
          ctx.fillText(l, x, h - 10);
        });

        ctx.textAlign = "left";
        ctx.fillText(t("chart_axis_left"), 8, 12);
        ctx.textAlign = "right";
        ctx.fillText(t("chart_axis_right", { min: minCo2, max: maxCo2 }), w - 8, 12);
      }

      async function fetchState() {
        if (!pin) return;
        try {
          const res = await fetch(`/api/classes/${pin}/state`);
          if (!res.ok) throw new Error("not found");
          const data = await res.json();
          renderSensors(data.last_sensor);
          aggregateEmotions(data.emotions || []);
          renderChart();
          renderSummary(data);
          setStatus(t("status_connected_with_count", { pin, count: data.emotions?.length || 0 }));
          setStatusCompact(t("status_connected", { pin }));
          if (sensorPill) sensorPill.textContent = t("pill_live");
          if (livePill) livePill.textContent = t("pill_live");
          if (downloadBtn) downloadBtn.disabled = false;
          renderCompact(data);
        } catch (e) {
          setStatus(t("status_fetch_failed"), true);
          setStatusCompact(t("status_fetch_failed"));
          if (downloadBtn) downloadBtn.disabled = true;
        }
      }

      function envStatus(type, val) {
        if (val == null) return "warning";
        if (type === "co2") {
          if (val <= 800) return "good";
          if (val <= 1400) return "warning";
          return "danger";
        }
        if (type === "temperature") {
          if (val >= 20 && val <= 24) return "good";
          if (val >= 18 && val <= 27) return "warning";
          return "danger";
        }
        if (type === "noise") {
          if (val <= 50) return "good";
          if (val <= 65) return "warning";
          return "danger";
        }
        if (type === "voc") {
          if (val <= 400) return "good";
          if (val <= 2200) return "warning";
          return "danger";
        }
        if (type === "lux") {
          if (val >= 300 && val <= 750) return "good";
          if (val >= 150 && val < 300) return "warning";
          if (val > 750 && val <= 1000) return "warning";
          return "danger";
        }
        return "warning";
      }

      // Get a timestamp (ms) for an emotion item, robust to field name differences
      function eventTimeMs(e) {
        const t = e?.received_at || e?.timestamp || e?.created_at;
        const ms = t ? new Date(t).getTime() : NaN;
        return Number.isFinite(ms) ? ms : 0;
      }

      // Keep only emotions within the last `windowMs` (default 60s)
      function filterRecent(emotions = [], windowMs = 60_000) {
        const cutoff = Date.now() - windowMs;
        return emotions.filter((e) => eventTimeMs(e) >= cutoff);
      }

      function computeBreakdown(emotions = [], windowMs = 60_000) {
        const recent = filterRecent(emotions, windowMs);
        const counts = { ok: 0, lost: 0, overloaded: 0, tired: 0 };

        recent.forEach((e) => {
          const p = e.payload || {};
          if (p.pace) {
            if (p.pace === "ok") counts.ok += 1;
            if (p.pace === "too-fast") counts.lost += 1;
            if (p.pace === "overloaded") counts.overloaded += 1;
            if (p.pace === "tired") counts.tired += 1;
          } else if (typeof p.focus === "number") {
            const f = Number(p.focus);
            if (f < 25) counts.lost += 1;
            else if (f < 50) counts.overloaded += 1;
            else counts.ok += 1;
          }
        });

        const total = counts.ok + counts.lost + counts.overloaded + counts.tired;
        const pct = total
          ? {
              ok: Math.round((counts.ok / total) * 100),
              lost: Math.round((counts.lost / total) * 100),
              overloaded: Math.round((counts.overloaded / total) * 100),
              tired: Math.round((counts.tired / total) * 100),
            }
          : { ok: 0, lost: 0, overloaded: 0, tired: 0 };

        const dominant =
          total === 0
            ? "idle"
            : ["ok", "lost", "overloaded", "tired"].reduce((a, b) => (counts[b] > counts[a] ? b : a), "ok");

        return { counts, pct, dominant, total, windowMs, recentCount: total };
      }

      function updateBreakdownOverlay(breakdown) {
        if (!breakdown) return;
        lastBreakdown = breakdown;
        const safePct = (v) => Math.max(0, Math.min(100, v || 0));
        const entries = [
          ["ok", "valOk", "fillOk"],
          ["overloaded", "valOverloaded", "fillOverloaded"],
          ["tired", "valTired", "fillTired"],
          ["lost", "valLost", "fillLost"],
        ];
        entries.forEach(([key, valId, fillId]) => {
          const pct = safePct(breakdown.pct?.[key]);
          const valEl = document.getElementById(valId);
          const fillEl = document.getElementById(fillId);
          if (valEl) valEl.textContent = `${pct}%`;
          if (fillEl) fillEl.style.width = `${pct}%`;
        });
      }

      function showBreakdown() {
        if (!breakdownOverlay || !lastBreakdown) return;
        updateBreakdownOverlay(lastBreakdown);
        breakdownOverlay.classList.add("show");
        breakdownVisible = true;
      }

      function hideBreakdown() {
        if (!breakdownOverlay) return;
        breakdownOverlay.classList.remove("show");
        breakdownVisible = false;
      }

      function renderSummary(data) {
        const envVals = {
          co2: data?.last_sensor?.sensors?.eco2_ppm ?? null,
          temperature: data?.last_sensor?.sensors?.temperature_c ?? null,
          noise: data?.last_sensor?.sensors?.noise_db ?? null,
          voc: data?.last_sensor?.sensors?.voc_ppb ?? null,
          lux: data?.last_sensor?.sensors?.brightness_lux ?? null,
        };
        const envStatuses = {
          co2: envStatus("co2", envVals.co2),
          temperature: envStatus("temperature", envVals.temperature),
          noise: envStatus("noise", envVals.noise),
          voc: envStatus("voc", envVals.voc),
          lux: envStatus("lux", envVals.lux),
        };

        const breakdown = computeBreakdown(data?.emotions || []);
        updateBreakdownOverlay(breakdown);
        const dominant = breakdown.dominant;

        const color =
          {
            ok: "#95c11f",
            lost: "#ef4444",
            overloaded: "#facc15",
            tired: "#f59e0b",
            idle: "#94a3b8",
          }[dominant] || "#94a3b8";

        const iconHtml =
          {
            ok: `<img src="src/state-ok.svg" alt="${t("state_engaged")}" />`,
            lost: `<img src="src/state-lost.svg" alt="${t("state_lost")}" />`,
            overloaded: `<img src="src/state-overloaded.svg" alt="${t("state_overload")}" />`,
            tired: `<img src="src/state-tired.svg" alt="${t("state_tired")}" />`,
            idle: `<img src="src/state-ok.svg" alt="${t("state_waiting")}" />`,
          }[dominant] || `<img src="src/state-ok.svg" alt="${t("state_monitor")}" />`;

        const labelKey =
          {
            ok: "state_engaged",
            lost: "state_lost",
            overloaded: "state_overload",
            tired: "state_tired",
            idle: "state_waiting",
          }[dominant] || "state_monitor";
        const label = t(labelKey);

        const message = (() => {
          if (envStatuses.co2 === "danger") return t("message_open_window");
          if (breakdown.total === 0) return t("message_waiting_feedback");
          switch (dominant) {
            case "ok":
              return t("message_engaged");
            case "overloaded":
              return t("message_overloaded");
            case "tired":
              return t("message_tired");
            case "lost":
              return t("message_lost");
            default:
              return t("message_monitor");
          }
        })();

        const pill = document.getElementById("summaryPill");
        const circle = document.getElementById("summaryCircle");
        const icon = document.getElementById("summaryIcon");
        const labelEl = document.getElementById("summaryLabel");
        const brk = document.getElementById("summaryBreakdown");
        const sug = document.getElementById("summarySuggestion");

        if (pill) pill.textContent = t("pill_live");
        if (circle) {
          circle.style.setProperty("--climate", color);
          circle.classList.remove("pulse");
          void circle.offsetWidth;
          circle.classList.add("pulse");
        }
        if (icon) icon.innerHTML = iconHtml;
        if (labelEl) {
          labelEl.textContent = label;
          labelEl.style.color = color;
        }
        if (brk) {
          const span = Math.round(breakdown.windowMs / 1000);
          brk.textContent =
            breakdown.total === 0
              ? t("summary_no_recent", { span })
              : t("summary_breakdown", {
                  ok: breakdown.pct.ok,
                  lost: breakdown.pct.lost,
                  overload: breakdown.pct.overloaded,
                  tired: breakdown.pct.tired,
                  span,
                });
        }
        if (sug) sug.textContent = message;
      }

      function renderCompact(data) {
        const envVals = {
          co2: data?.last_sensor?.sensors?.eco2_ppm ?? null,
          temperature: data?.last_sensor?.sensors?.temperature_c ?? null,
          noise: data?.last_sensor?.sensors?.noise_db ?? null,
          voc: data?.last_sensor?.sensors?.voc_ppb ?? null,
          lux: data?.last_sensor?.sensors?.brightness_lux ?? null,
        };
        const envStatuses = {
          co2: envStatus("co2", envVals.co2),
          temperature: envStatus("temperature", envVals.temperature),
          noise: envStatus("noise", envVals.noise),
          voc: envStatus("voc", envVals.voc),
          lux: envStatus("lux", envVals.lux),
        };
        const envList = [
          { key: "co2", label: t("env_air"), unit: "ppm" },
          { key: "temperature", label: t("env_temp"), unit: "¬∞C" },
          { key: "noise", label: t("env_noise"), unit: "dB" },
          { key: "voc", label: t("env_voc"), unit: "ppb" },
          { key: "lux", label: t("env_lux"), unit: "lx" },
        ]
          .map((row) => {
            const val = envVals[row.key];
            const st = envStatuses[row.key];
            const dotClass = (idx) => {
              if (st === "good" && idx === 0) return "is-good";
              if (st === "warning" && idx === 1) return "is-warning";
              if (st === "danger" && idx === 2) return "is-danger";
              return "";
            };
            return `
              <div class="c-env-tile">
                <div class="c-env-row">
                  <div class="c-env-meta">
                    <div class="c-env-label">${row.label}</div>
                    <div class="c-env-value">${val != null ? `${Math.round(val)} ${row.unit}` : "n/a"}</div>
                  </div>
                  <div class="c-env-dots">
                    <span class="c-env-dot ${dotClass(0)}"></span>
                    <span class="c-env-dot ${dotClass(1)}"></span>
                    <span class="c-env-dot ${dotClass(2)}"></span>
                  </div>
                </div>
              </div>
            `;
          })
          .join("");
        const cEnvList = document.getElementById("cEnvList");
        if (cEnvList) cEnvList.innerHTML = envList;

        const breakdown = computeBreakdown(data?.emotions || []);
        const dominantColor =
          {
            ok: "#95c11f",
            lost: "#ef4444",
            overloaded: "#facc15",
            tired: "#f59e0b",
            idle: "#94a3b8",
          }[breakdown.dominant] || "#94a3b8";
        const iconSvg = (() => {
          switch (breakdown.dominant) {
            case "ok":
              return `<img src="src/state-ok.svg" alt="${t("state_engaged")}" class="state-icon" />`;
            case "lost":
              return `<img src="src/state-lost.svg" alt="${t("state_lost")}" class="state-icon" />`;
            case "overloaded":
              return `<img src="src/state-overloaded.svg" alt="${t("state_overload")}" class="state-icon" />`;
            case "tired":
              return `<img src="src/state-tired.svg" alt="${t("state_tired")}" class="state-icon" />`;
            default:
              return `<img src="src/state-ok.svg" alt="${t("state_engaged")}" class="state-icon" />`;
          }
        })();
        const labelKey =
          {
            ok: "state_engaged",
            lost: "state_lost",
            overloaded: "state_overload",
            tired: "state_tired",
            idle: "state_waiting",
          }[breakdown.dominant] || "state_monitor";
        const label = t(labelKey);

        const message = (() => {
          if (envStatuses.co2 === "danger") return t("message_open_window");
          if (breakdown.total === 0) return t("message_waiting_feedback");
          switch (breakdown.dominant) {
            case "ok":
              return t("message_engaged");
            case "overloaded":
              return t("message_overloaded");
            case "tired":
              return t("message_tired");
            case "lost":
              return t("message_lost");
            default:
              return t("message_monitor");
          }
        })();

        const center = document.querySelector(".c-center");
        const circle = document.getElementById("cCircle");
        const emojiEl = document.getElementById("cEmoji");
        const labelEl = document.getElementById("cLabel");
        const msgEl = document.getElementById("cMessage");
        if (center) center.style.setProperty("--climate-color", dominantColor);
        if (circle) {
          circle.classList.remove("circle-pulse");
          void circle.offsetWidth;
          circle.classList.add("circle-pulse");
        }
        if (emojiEl) emojiEl.innerHTML = iconSvg;
        if (labelEl) {
          labelEl.textContent = label;
          labelEl.style.fontSize = "20px";
        }
        if (msgEl) msgEl.textContent = message;
      }

      async function downloadClassState() {
        if (!pin) {
          setStatus(t("status_pin_required"), true);
          return;
        }
        try {
          const res = await fetch(`/api/classes/${pin}/state`);
          if (!res.ok) throw new Error("not found");
          const data = await res.json();
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `class-${pin}-state.json`;
          a.click();
          URL.revokeObjectURL(url);
          setStatus(t("status_download_ok", { pin }));
        } catch (e) {
          setStatus(t("status_download_fail"), true);
        }
      }

      function pinFromQuery() {
        try {
          const params = new URLSearchParams(window.location.search);
          const qPin = params.get("pin") || params.get("class_pin");
          return (qPin || "").trim();
        } catch (e) {
          return "";
        }
      }

      let pinEditMode = false;
      function updatePinUI() {
        const hasPin = !!pin;
        const compact = document.body.classList.contains("compact-mode");
        const showInputs = !compact || !hasPin || pinEditMode;
        const showBadge = compact && hasPin && !pinEditMode;

        const inputs = [pinInput, cPinInput, cPinInputInline];
        const buttons = [connectBtn, cConnectBtn, cConnectBtnInline];
        inputs.forEach((inp) => {
          if (!inp) return;
          inp.readOnly = false;
          inp.style.display = showInputs ? "inline-flex" : "none";
        });
        buttons.forEach((btn) => {
          if (!btn) return;
          btn.style.display = showInputs ? "inline-flex" : "none";
        });
        if (cPinBadge) {
          cPinBadge.style.display = showBadge ? "inline-flex" : "none";
          cPinBadge.textContent = hasPin ? `${pin}` : "";
        }
      }

      function connectWithPin(entered) {
        const pinVal = (entered || "").trim();
        if (!pinVal) {
          setStatus(t("status_pin_required"), true);
          setStatusCompact(t("status_pin_required"));
          return;
        }
        pinEditMode = false;
        setPin(pinVal);
        localStorage.setItem("class_pin", pinVal);
        setStatusCompact(t("status_connecting"));
        fetchState().catch(() => {});
        clearInterval(pollTimer);
        pollTimer = setInterval(fetchState, 5000);
      }

      setTheme(theme);
      applyTranslations();

      if (themeBtn) {
        themeBtn.onclick = () => {
          setTheme(theme === "dark" ? "light" : "dark");
        };
      }

      if (connectBtn) {
        connectBtn.onclick = () => connectWithPin(pinInput?.value || "");
      }
      if (cConnectBtn) {
        cConnectBtn.onclick = () => connectWithPin(cPinInput?.value || "");
      }
      if (cConnectBtnInline) {
        cConnectBtnInline.onclick = () => connectWithPin(cPinInputInline?.value || "");
      }
      if (cPinBadge) {
        cPinBadge.onclick = () => {
          pinEditMode = true;
          updatePinUI();
          if (cPinInput) {
            cPinInput.focus();
            cPinInput.select();
          }
        };
      }
      if (cCenter) {
        cCenter.onclick = () => {
          if (!pin) return;
          if (breakdownVisible) hideBreakdown();
          else showBreakdown();
        };
      }
      if (breakdownOverlay) breakdownOverlay.onclick = hideBreakdown;
      if (breakdownCard) breakdownCard.onclick = (e) => e.stopPropagation();
      if (downloadBtn) downloadBtn.onclick = downloadClassState;
      const savedPin = localStorage.getItem("class_pin");
      const paramPin = pinFromQuery();
      const params = new URLSearchParams(window.location.search);
      const displayOnly = (() => {
        const raw = params.get("display") || params.get("display_only") || params.get("readonly");
        if (raw == null) return false;
        const val = raw.toString().toLowerCase();
        return val === "" || val === "1" || val === "true" || val === "yes";
      })();

      if (displayOnly) {
        document.body.classList.add("display-only");
        if (downloadBtn) downloadBtn.style.display = "none";
      }
      if (paramPin) {
        connectWithPin(paramPin);
      } else if (savedPin) {
        connectWithPin(savedPin);
      }
      applyMode();
      window.addEventListener("resize", applyMode);
    </script>
  </body>
</html>
